# 13.复制控制

==**复制构造函数**==是一种特殊的构造函数，具有单个形参，该形参（常用const修饰符）是对该类类型的引用。当定义一个新的新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或从函数返回该类型的对象时，将隐式使用复制构造函数。

==**析构函数**==是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命中周期所获取的资源。不管我们是否定义了自己的析构函数，编译器都自动执行类中非static数据成员的析构函数。

复制构造函数、赋值操作符和析构函数总称为赋值控制。编译器自动实现这些操作，但类也可以定义自己的版本。

实现赋值控制最难的部分，往往在于识别需要覆盖默认的版本。有一种特别常见的需要定义类自己的复制控制成员的：类具有指针成员。

## 13.1 复制构造函数

具有单个形参，该形参（常用const修饰符）是对该类类型的引用，这样的构造函数统称为复制构造函数。复制构造函数可用于：

+ 根据另一个同类型的对象显示或隐式初始化一个对象
+ 复制一个对象，将它作为实参传给一个函数
+ 从函数返回时复制一个对象
+ 初始化顺序容器中的元素
+ 根据元素初始化式列表初始化数组元素

####  1 对象的定义形式

~~~c++
string null_book = "9-999-99999-9";   //复制构造函数 
string dots(10, '.');                 //直接初始化
string empty_copy = string();         // 复制构造初始化
string empty_direct;                  //直接定义初始化
~~~

~~~
ifstream file1("filename");           //直接初始化
ifstream file2 = "filename";          //错误，构造函数为私有的（流对象不能复制）

Sales_item item = string("9-999-99999-9");    //仅当Sales_item类的构造函数为非explicit时有用
~~~

#### 2 形参与返回值

当形参为非引用类型时，将复制实参的值。类似地，以非引用类型作返回值时，将返回return语句中的值的副本。

当形参为或返回值为类类型时，由复制构造函数进行复制。

#### 3 初始化容器元素

复制构造函数可用于初始化顺序容器中的元素。容器的这种构造方式使用了默认构造函数和复制控制函数：

~~~
vector<string> svec(5);   //string默认构造函数5个复制构造函数
~~~

#### 4 构造函数与数组元素

如果没有为类类型数组提供元素初始化式，则将使用默认的构造函数初始化每个元素。然而，如果使用常规的花括号括住的数组初始化列表来提供显示元素初始化式，则使用复制初始化类初始化每个元素。

~~~
Sales_item primer_ends[] = {string("0-201-16478-6"),
							string("0-201-54848-8"),
							string("0-201-82470-1"),
							Sales_item()					
                                                  };
~~~

### 13.1.1 合成的复制构造函数

如果我们没有定义复制构造函数，编译器就会为我们合成一个。合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。

### 13.1.2 定义自己的复制构造函数

~~~
class Foo{
public：
	Foo();
	Foo(const Foo&)；
};
~~~

虽然也可以定义接收非const引用的复制构造函数，但形参通常是一个const引用。因为用于向函数传递对象和从函数返回对象，该构造函数一般不应设置为explicit。复制构造函数应将实参的成员复制到正在构建的对象。

只包含类类型和内置类型（但不是指针类型）成员的类，无须显式定义复制构造函数，也可以复制。

有些类必须对复制对象是发生的事情加以控制。这样的类经常有一个数据成员时指针，或者有成员表示在构造函数中分配的其他资源。而另一些类在创建新对象是必须做一些特定工作。这两种情况下，都必须定义复制构造函数。

### 13.1.3 禁止复制

有些类需要完全禁止复制。例如，iostream类就不允许复制。为了防止复制，类必须显式声明其复制构造函数为private。

然而，类的友元和成员还是可以进行复制。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。使用未定义成员的任何尝试都将导致==链接==失败。通过声明但不定义private构造函数可以禁止任何复制类类型对象的尝试：用户代码中的复制尝试将在编译时标记为错误，而成员函数和友元中的复制尝试将在链接时导致错误。

**大多数类应定义复制构造函数和默认构造函数**

## 13.2 赋值操作符

### 1 重载赋值

大多数操作符可以定义为成员函数和非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到this指针。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以this绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一个类类型的对象。右操作数一般作为const引用传递。

赋值操作符的返回类型应该与内置类型赋值操作符返回的类型相同。内置类型的赋值运算符返回对有操作数的引用，因此，赋值操作符也返回对同一类型的引用。

~~~
class Sales_item
{
	public:
		Sales_item& operator=(const Sales_item&);
};
~~~

### 2.合成赋值操作符

与合成复制构造函数的操作类似。它会执行逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。除数组之外，每个成员用所属类型的常规方式进行赋值。对于数组，对每个数组成员赋值。

例如，Sales_item的合成赋值操作符可能如下：

~~~
Sales_item& Sales_item::operator=(const Sales_item &rhs)
{
	isbn = rhs.isbn;					//使用string::operator=
	units_sold = rhs.units_sold;		//使用int的赋值操作
	revenue = rhs.revenue;				//使用double的赋值操作
	return *this;
}
~~~

### 3.复制和赋值常一起使用

可以使用合成复制构造函数的类通常也可以使用合成赋值操作符。我们的Sales_item类无须定义复制构造函数或赋值操作符，这些操作符的合成版本工作的更好。

然而，类也可以定义自己的赋值操作符。一般而言，如果类需要复制构造函数，它也会需要赋值操作符。实际上，应将这两个操作符看作一个单元。如果需要其中一个，我们几乎也肯定需要另一个。

## 13.3 析构函数

构造函数的一个用途是自动获取资源。例如，构造函数可以分配一个缓冲区或打开一个文件，在构造函数中分配了资源之后，需要一个对应操作自动回收或释放资源。析构函数就是这样的一个特殊函数，它可以完成所需的资源回收，作为类构造函数的补充。

###  1.何时调用析构函数

撤销对象时会自动调用析构函数：

~~~
Sales_item *p = new Sales_item;
{
	Sales_item item(*p);
	delete p;				//调用析构函数撤销p
 }							//作用域结束，调用item的析构函数。
~~~

当对象的引用或指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象（不是对象的引用）超出作用域时，才会运行析构函数。

撤销一个容器（不管是标准库类型还是内置数组）时，也会运行容器中的类类型元素的析构函数：

~~~
{
	Sales_item *p = new Sales_item[10]; //动态数组
	vector<Sales_item> vec(p, p+10);	//局部对象
	...
	delete []p;							//释放数组，对每个元素运行析构函数
}			//作用域结束，撤销vec。
~~~

### 2. 何时编写显示析构函数

析构函数通常用于释放在构造函数或在对象生命周期内获取的资源。

如果类需要析构函数，则它也需要复制操作符和复制构造函数，这是一个有用的经验法则。这个规则常称为三法则，指的是如果需要析构函数，则需要所有这三个复制控制成员。

### 3，合成析构函数

编译器总会为我们合成一个析构函数。合成析构函数按对象创建时的逆序撤销每个非static成员，因此，它按成员在类中声明次序的逆序撤销成员。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。

### 4.如何编写析构函数

Sales_item类是类没有分配资源因此不需要自己的析构函数的一个例子。分配了资源的类一般需要定义析构函数以释放那些资源。析构函数是个成员函数，它的名字是在类名字之前加上一个代字号（~），它没有返回值，没有形参。因为不能指定任何形参，所以不能重载析构函数。虽然可以为一个类定义多个构造函数，但只能提供一个析构函数，应用于类的所有对象。

析构函数与复制构造函数或赋值操作符的一个重要区别是，即使我们编写了自己的析构函数，合成的析构函数仍然运行。Sales_item类的析构函数这么写；

~~~
class Sales_item {
public:
	~Sales_item() {}		
};
~~~

撤销Sales_item类型的对象时，将运行这个什么也不做的析构函数，它执行完毕后，将运行合成的析构函数以撤销类的成员。