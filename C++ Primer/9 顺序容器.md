# Chapter 9 顺序容器

| 顺序容器的类型   |                      |
| ---------------- | -------------------- |
| 顺序容器         |                      |
| vector           | 支持快速随机访问     |
| list             | 支持快速插入\删除    |
| deque            | 双端队列             |
| 顺序容器是适配器 |                      |
| stack            | 后进先出（LIFO）栈   |
| queue            | 先进先出（FIFO）队列 |
| priority_queue   | 有优先级管理的队列   |

## 1.顺序容器的定义

### 1.1 初始化

| 容器构造函数 |                                                              |
| ------------ | ------------------------------------------------------------ |
| C<T> c;      | 创建一个名为c的空容器。C是容器类型名，如vector，T是元素类型，如int或string。适用于所有容器。 |
| C c(c2);     | 创建容器c2的副本；c和c2必须具有相同的容器类型，并存放相同类型的元素。适用于所有容器。 |
| C c(b, e);   | 创建c，其元素是迭代器b和e标示的范围内元素的副本，适用于所有容器。 |
| C c(n, t);   | 用n个值为t的元素创建容器c，其中值t必须是容器类型C的元素类型的值，或者可以转换为该类型的值。**只适用于顺序容器** |
| C c(n);      | 创建有n个值初始化元素的容器c。**只适用于顺序容器**           |

将一个容器初始化为另一个容器的副本（**容器类型和元素类型都要匹配**）

~~~
vector<int> ivec;
vector<int> ivec2(ivec);
list<int> ilist(ivec); //错误；容器类型和元素类型均不匹配
vector<double> dvec(ivec); //错误：元素类型不匹配
~~~

将容器初始化为一段元素的副本（**则不考虑容器类型，但元素类型要匹配或者可转换**）

### 1.2 容器内元素的类型约束

容器元素类型必须满足以下两个约束：

+  元素类型必须支持复制运算
+ 元素类型的对象必须可以复制

所以没有元素是引用的容器也没有元素是IO对象的容器。可以定义元素本身就是容器类型的容器。

~~~
vector< vector<string> > lines;
vector< vector<string>> lines;//错误；系统认为>>是单个操作符
~~~



## 2.迭代器和迭代器范围

~~~
*iter //返回迭代器iter所指向的元素
iter->mem //对iter进行解引用，获取指定元素中名为mem的成员，等效于（*iter）.mem
//还有其他常见的迭代器运算
~~~

| vector和deque类型迭代器支持的操作 |                                                              |
| --------------------------------- | ------------------------------------------------------------ |
| iter + n                          | 迭代器向前或向后移动，计算结果必须指向容器中元素或者容器末端的下一个位置 |
| iter - n                          |                                                              |
| iter1 += iter2                    | 迭代器加减赋值                                               |
| iter1 -= iter2                    |                                                              |
| iter1 - iter2                     | 同一个容器中的两个迭代器的距离。**只适用于vector和deque**    |
| >, >=, <, <=                      | 迭代器关系操作符。**只适用于vector和deque**                  |

### 2.1 迭代器范围

c++使用一对迭代器标记迭代器范围，分别为指向同一个容器中的两个元素或超出末端的下一个位置。

此类元素范围成为**左闭合区间**，其标准表示方式为：

**==[ first, last )==**

==**使用迭代器编写程序时，必须留意哪些操作会使迭代器失效。使用无效迭代器将会导致严重的运行时错误**==

## 3.顺序容器的操作

### 3.1 容器定义的类型别名

| 容器定义的类型别名     |                                                  |
| ---------------------- | ------------------------------------------------ |
| size_type              | 无符号整形                                       |
| iterator               | 迭代器类型                                       |
| const_iterator         | 只读迭代器类型                                   |
| reverse_iterator       | 按逆序寻址元素的迭代器                           |
| const_reverse_iterator | 元素的只读逆序迭代器                             |
| difference_type        | 有符号整形，存储两个迭代器的差值                 |
| value_type             | 元素类型                                         |
| reference              | 元素的左值类型，是value_type&的同义词            |
| const_reference        | 元素的常量左值类型，是 const value_type&的同义词 |

### 3.2 begin和end成员

~~~
c.begin(); //指向容器c的第一个元素
c.end(); //指向容器c的最后一个元素的下一个元素
c.rbegin(); //逆序迭代器，指向容器c的最后一个元素
c.rend(); //逆序迭代器，指向容器c的第一个元素前面的元素
~~~



### 3.3 在顺序容器中插入元素

~~~
c.push_back(t); //在容器尾部添加值为t的元素。返回void类型
c.push_front(t); //在容器头部添加值为t的元素。返回void类型
                   只适用于list和deque容器类型
c.insert(p, t); //在迭代器p所指向的元素前面插入值为t的新元素。返回指向新添加元素的迭代器
c.insert(p, n, t); //在迭代器p所指向的元素前面插入n个值为t的新元素。返回void
c,insert(p, b, e); //在迭代器p所指向的元素前面插入由迭代器b和e标记的范围内的元素。返回void
~~~

**容器元素都是副本**

==**任何insert或push操作都有可能导致迭代器失效。当编写循环将元素插入到vector或者deque中时，程序员必须确保迭代器在每次循环后都得到更新**==

==**不要存储end操作返回的迭代器。添加或删除deque或vector容器内的元素都会导致存储的迭代器失效**==

### 3.4 容器大小的操作

~~~
c.size(); //返回容器c的元素个数。返回类型为c::size_type
c.max_size(); //返回容器c最多可容纳多少元素
c.empty(); //返回容器c大小是否为0的布尔值
c.resize(n); //调整容器c的大小，使其能容纳n的元素
c.resize(n, t) //调整容器c的大小，使其能容纳n的元素。所以新添加的元素的值为t
~~~

### 3.5 访问元素

~~~
c.back(); //返回容器c的最后一个元素的引用。如果c为空,则操作未定义。
c.front(); //返回容器c的第一个元素的引用。如果c为空,则操作未定义。
c[n]; //返回容器下标为n的元素的引用。如果n>=c.size()或c<=0,则操作未定义。
		只适用于vector和deque
c.at(n); //返回容器下标为n的元素的引用。如果下标越界，则该操作为定义。
		只适用于vector和deque
~~~

### 3.6 删除元素

~~~
c.erase(p); //删除迭代器p指向的元素。
				返回一个迭代器，它指向被删除元素的后一个元素。如果p本身是指向末端的后一个元素，则操作					未定义。
c.erase(b, e); //删除迭代器p和迭代器e范围内的元素。
				返回一个迭代器，它指向被删除元素的后一个元素。如果e本身是指向末端的后一个元素,则返回					的迭代器也指向末端的后一个元素
c.clear(); // 删除容器的所有元素。返回void
c.pop_back(); //删除容器c的最后一个元素。返回void。如果c为空容器，则未定义。
c.pop_front(); //删除容器c的第一个元素。返回void。如果c为空容器，则未定义。
				只适用于list或者deque
~~~

### 3.7 赋值与swap

1.与赋值相关的操作都是作用于整个荣容器。

**==赋值和assign操作使左操作数容器的所有迭代器失效。swap操作则不会使迭代器失效。==**

~~~
c1 = c2; //删除c1的元素，将c2的元素赋给c1。c1和c2的容器和元素类型都必须一样。
c1.swap(c2); //交换c1和c2的内容。c1和c2的类型必须相同。
c.assign(b, e); //重新设置c的元素：将迭代器b和e标记范围内的元素复制到c中。b和e必须不是c中元素的迭代器。
c,assign(n, t); //将容器c重新设置为存储n个值为t的元素。
~~~

2.使用swap操作以节省删除元素的成本

swap操作交换两个相同类型的容器内容，除array外，交换两个容器内容的操作会保证非常快，因为并没有交换元素本身，而只是交换两个容器内部数据结构。

交换容器内部数据结构：交换容器中个元素的内存地址，并不是交换各个元素变量所存储的值。

## 4.vector容器的自增长

capacity和reserve成员：

size值容器当前拥有的元素个数；而capacity则值容器在必须分配新存储空间之前可以存储的元素总数。vector容器必须是在必要时才分配新的内存空间。分配多少内存取决于其实现方式。不同的库采用不同的策略实现。

## 5.容器的选用

选择容器的提示：

1. 如果程序要求随机访问元素，则应使用vector或者deque容器。
2. 如果程序必须在容器的中间位置插入或删除元素，则应采用list容器。
3. 如果程序不是在容器的中间位置，而是在容器的手部或尾部插入或着删除元素，则应采用deque容器。
4. 如果只需咋读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑在输入时将元素读入到一个list容器，接着对此容器重新排序，使其适合顺序访问，然后将排序后的list容器复制到一个vector中。

**如果无法确定某种应用应该采用哪种容器，则编写代码时尝试只适用vector和list容器都提供的操作：使用迭代器，而不是下标，并且避免随机访问元素。这样编写的代码，在必要时，可很方便的将程序从使用vector转为使用list容器**

## 6. 再谈string类型

### 6.1 构造string对象的其他方法

~~~
string s(cp, n); //string对象s被初始化为cp所指向数组的前n个元素的副本。
string s(s2, pos2); //string对象s被初始化为string对象s2中从下标0开始到pos2的字符的副本。若pos2>s2.size(),则操作未定义。
string s(s2, pos2, len2); //string对象s被初始化为string对象s2中从下标pos2开始。长度为len2的字符副本。若pos2>s2.size(),则操作未定义。无论len2为多少，最多只能复制s2.size()-pos2个字符。
~~~

### 6.2 修改string的对象的其他方法

~~~
//与容器共有的string操作
s.insert(p, t); //在p指向的位置插入一个值为t的元素。返回新插入值得迭代器。
s.insert(p, n, t); //在p指向的位置之前插入n个值为t的元素。返回void。
s.insert(p, b, e); //在p指向的位置之前插入迭代器b和e范围之间的所有元素。返回void

s.assign(b, e); //用迭代器b和e范围之间的所有元素替换s。对于string类型，返回s;对于容器类型，则返回void

s.assign(n, t); //用值为t的n个元素替换s。对于string类型，返回s;对于容器类型，则返回void

s.erase(p); //删除迭代器p指向的元素。返回一个迭代器，指向被删除元素之后的元素位置。
s.erase(p, e); //删除迭代器b和e范围之间的所有元素。返回一个迭代器，指向被删除元素之后的元素位置。
~~~

~~~
//string类型特有的版本
s.insert(pos, n, c); //在下标为pos之前插入n个字符c
s.insert(pos, s2); //在下标为pos之前插入string对象s2的副本
s.insert(pos, s2, pos2, len); //在下标为pos之前插入string对象s2中从下标pos2开始的len个字符

s.insert(pos, cp, len); //在下标为pos之前插入cp数组的前len个字符
s.insert(pos, cp); //在下标为pos之前插入以空字符结束的cp字符数组

s.assign(s2); //用s2的副本替换s
s.assign(s2, pos2, len); //用s2中从下标pos2开始的len个字符替换s
s.assign(cp, len); //用cp数组的前len个字符替换s
s.assign(cp); //用以空字符结束的cp字符数组替换s

s.erase(pos, len); //删除从下标pos开始的len个字符
//除非特殊声明，以上操作都返回s的引用
~~~

### 6.3 只适用于string类型的操作

1. 子串操作

   ~~~
   s.substr(pos, n); //返回一个string类型的字符串，它包含s中从下标pos开始n个字符
   s.substr(pos); //返回一个string类型的字符串,它包含s中从下标pos开始到s末尾的所有字符
   s.substr(); //返回s的副本
   ~~~

2. append和replace函数

   ~~~
   s.append(args); //将args接在s的后面。返回s的引用
   
   s.replace(pos, len, args); //删除s中从下标pos开始的len个字符，用args指定的字符替换。返回s的引用  这个版本，args不能为b2, e2。
   s.replace(b, e, args); //删除迭代器b和e范围之间的所有元素，用args替换。返回s的引用 这个版本，args不能为s2, pos2, len2。  
   ~~~

   | append和replace操作的参数：args |                                          |
   | ------------------------------- | ---------------------------------------- |
   | s2                              | string类型的字符串s2                     |
   | s2, pos2, len2                  | 字符串s2中从下标pos2开始的len2个字符     |
   | cp                              | 指针cp指向的以空字符结束的数组           |
   | cp, len2                        | cp指向的以空字符结束的数组中前len2个字符 |
   | n, c                            | 字符c的n个副本                           |
   | b2, e2                          | 迭代器b2和e2标记的范围内所有的字符       |

   **不要求删除的文本长度与插入的相同**

### 6.4 string类型的查找操作

~~~
//string类型的查找操作,args同上
s.find(args)； //在s中查找args的第一次出现
s.rfind(args); //在s中查找args的最后一次出现

s.find_first_of(args); //在s中查找args中任意字符的第一次出现
s.find_last_of(args); //在s中查找args中任意字符的最后一次出现
s.find_first_not_of(args); //在s中查找第一个不属于args的字符
s.find_last_not_of(args); //在s中查找最后一个不属于args的字符
~~~

~~~
//string类型提供的find操作的参数
c, pos  //在s中，从下标pos标记的位置开始，查找字符c。pos的默认值为0
s2, pos  //在s中，从下标pos标记的位置开始，查找string对象s2。pos的默认值为0
cp, pos  //在s中，从下标pos标记的位置开始，查找指针cp所指向的c风格的以空字符为结束的字符串。pos的默认值为0
cp, pos, n  //在s中，从下标pos标记的位置开始，查找指针cp所指向数组的前n个字符。pos和n都没有默认值
~~~

### 6.5 string对象的比较

~~~
//string类型的compare操作
s.compare(s2); //比较s和s2
s.compare(pos1, n1, s2); //让s中从pos1下标位置开始的n1个字符与s2比较
s.compare(pos1, n1, s2, pos2, n2); //让s中从pos下标位置开始的n1个字符与s2中从pos开始的n2个字符比较

s.compare(cp); //比较s与cp指向的c风格字符串
s.compare(pos1, n1, cp); //让s中从pos1下标位置开始的n1个字符与cp指向的c风格字符串比较

s.compare(pos1, n1, cp, n2); //让s中从pos1下标位置开始的n1个字符与cp指向的c风格字符串前n2个字符比较
~~~



## 7. 容器适配器

适配器的本质是：使一种事物的行为类似于另一种事物的行为的一种机制。

三种顺序容器适配器：

1. queue
2. stack
3. priority_queue

~~~
//适配器的通用操作和类型
size_type  //一种类型，足以存储适配器类型的最大对象的长度
value_type  //元素类型
container_type  //基础容器的类型，适配器在次基础上实现
A a;  //创建一个空适配器，名为a
A a(c);  //创建一个空适配器，名为a,并初始化为c的副本
~~~

### 7.1 栈适配器

~~~
s.empty(); //栈判空
s.size(); //返回栈的大小
s.pop(); //栈顶元素出栈
s.top(); //返回栈顶元素的值，但不删除该元素
s.push(item) //在栈顶压入元素
~~~

### 7.2 队列和优先级队列

~~~
//队列和优先级队列的操作
q.empty(); //队列判空
q.size(); //返回队列中元素的大个数
q.pop(); //删除队首元素，不返回其值    
q.front(); //返回队首元素，不删除   只适用队列

q.back(); //返回队尾元素，不删除    只适用队列

q.top(); //返回队列中优先级最高的元素值，不删除   只适用于优先级队列
q.push(item) //对于队列，在队尾加入元素；
				对于优先级队列，基于优先级在适当的位置插入新元素
~~~



