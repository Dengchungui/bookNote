# 高级数据结构



+ 优先队列 / Priority Queue
+ 图 / Graph
+ 前缀树 / Trie
+ 线段树 / Segment Tree
+ 树状数组 / Fenwick Tree / Binary Indexed Tree

## 1.1 优先队列

与普通队列的区别：

+ **保证每次取出的元素是队列中优先级最高的**
+ **优先级别可自定义**

最常用场景：

*从杂乱无章的数据中按照一定的顺序（或者优先级）筛选数据*

**例子**：任意一个数组，找出前K大的树。

解法一：先排序，在一次输出前K个数，复杂度是O(nlogn).

解法二：用优先队列，复杂度优化成O(K+nlogk)。

**本质：**

+ 二叉树的结构，堆在英文里叫做Binary Heap
+ 利用一个*数组*来实现==完全二叉树==

**特性**：

1. 数组里的第一个元素array[0]拥有最高的优先级。
2. 给定一个下标i,那么对于元素array[i]而言：

+ **父节点** 对应的元素下标是（i - ）/ 2 
+ **左侧子节点** 对应的元素下标是2*i +1
+ **右侧子节点** 对应的元素下标是2*i +2 

3. 数组里每个元素额优先级都高于其两个子节点的优先级。

其基本操作有以下两个：

+ **向上筛选**
  1. 当有新的数据加入优先队列时，新的数据首先被放置在二叉堆的底部。
  2. 不断地进行向上筛选的工作，即如果发现该数据的优先级高于其父节点，则与父节点的元素交换，一直到无法继续交换为止。
  3. 时间复杂度为O(logK),沿着树的高度往上走，输的高度为K。

+ **向下筛选**
  1. 当堆顶元素被取出，要更新堆顶的元素来维持完全二叉树的性质，需要将堆底部的元素放置到堆顶，然后不断地向下筛选
  2. 将该元素与他的两个孩子结点对比优先级，如果优先级最高的是其中的一个孩子，就将该元素和那个孩子交换然后反复进行下去，直到无法继续交换。
  3. 时间复杂度O(logk).

**初始化**

优先队列的初始化的时间复杂度为O(n)，推导过程不要求。初始化一个大小为n的堆，所需要的时间我O(n)。

![复杂度](L:\笔记\Typora笔记\拉钩_数据结构与算法\高级数据结构.assets\复杂度.png)

**例题分析** LeetCode 347题

给定一个非空的整数数组，返回其中出现评率前K的元素个数。

解题思路：

+ “前K个”，自然想到用优先队列。
+ 优先级为出现频率。
+ 统计词频用哈希表。
+ 将单词和其出现的次数作为一个新的对象来构建一个优先队列。

**建议**：此题为优先队列的经典题目，建议好好练习

## 1.2 图

**基本知识点**

+ 阶、度：出度、入度
+ 数、森林、环
+ 有向图、无向图、完全有向图、完全无向图
+ 连通图、连通分量
+ 存储和表达方式：邻接矩阵、邻接链表

围绕图的算法：

+ 图的遍历：深度优先、广度优先
+ 环的检测：有向图、无向图
+ 拓扑排序
+ 最短路径算法：Dijkstra、Bellman-Ford、Floyd-Warshall
+ 连通性相关算法：Kosaraju 、Tarjan、求解孤岛数量、判断是否为树
+ 图的着色、旅行商问题等

**必会知识点**

+ 图的存储和表达方式：邻接矩阵、邻接链表
+ 图的遍历：深度优先、广度优先
+ 二部图的检测、树的检测、环的检测：有向图、无向图
+ 拓扑排序
+ 联合-查找算法
+ 最短路径：Dijkstra、Bellman-Ford

  **图的遍历是重中之重，它是所有图论算法的基础**

**例题分析** LeetCode 785题：给定一个无向图，判断是否为二部图。

## 1.3 前缀树

被广泛的应用到字典查找当中，也被成为字典树。

**经典应用**

1. 网站上搜索框会罗列出一搜索文字作为开头的相关搜索信息，这里运用了前缀树进行后端快速搜索。
2. 汉字拼音输入法的联想功能也运用了前缀树。

**举例**：假如有一个字典，字典里面有如下词：“A“ ”to“ "tea" "ted" "ten" "i" "in" "inn",每一个词有自己的权重值，那么用前缀树来构建将是如下样子：

![前缀树 ](L:\笔记\Typora笔记\拉钩_数据结构与算法\高级数据结构.assets\前缀树 .png)

**性质**

1. 每个节点至少包含两个基本属性。

   + children:数组或者集合。罗列出每个分支当中包含的所有字符
   + isEnd：布尔值，表示该节点是否为某字符串的结尾

2. 前缀树的根节点是空的

   所谓空，即只利用节点的children属性，即只关心在这个字典中有哪些打头的字符。

3. 除了根节点，所有其他节点都有可能是单词的结尾，叶子节点一定是单词的结尾。

**实现**

前缀树的组基本的操作就两个：创建和搜索

1. 创建

   + 遍历一遍输入的字符串，对每个字符串的字符进行遍历
   + 从前缀树的根节点开始，将每个字符加入到这个节点的children字符集当中
   + 如果字符集已经包含了这个字符，则跳过
   + 如果当前字符是字符串的最后一个，则把当前节点的isEnd标记为真

2. 搜索

   从根节点出发，逐个匹配输入的前缀字符，如果遇到了就继续往下一层搜索，如果没遇到，就立即返回。

**例题分析**：LeetCode 212题：给定一个二维网格board和一个字典中单词列表words，找出所有同时在二维网格和字典中出现的单词。

**字典匹配的解法2**：对比字符串的前缀，借助前缀树来重新构建字典。

构建前缀树之后，每次从矩阵里的某个字符出发进行搜索时，同步地对前缀树进行对比，如果发现字符一直能被找到，就继续进行下去，一步一步的匹配，直到在前缀树里发现一个完整的字符串，把它输出即可。

## 1.4 线段树

**应用场景：**

+ 更新数组元素的值
+ 求任意一段区间里元素的总和（或者平均值）
+ 适用于数据很多，而且需要频繁更新并求和的操作。时间复杂度O(logn).

**实现**

线段树是一种按照==二叉树==的形式存储数据的结构，每个节点保存的都是数组里的某一段的总和

**举例**：数组是[1，3，5，7，9，11]，那么他的线段树如下。

![线段树](L:\笔记\Typora笔记\拉钩_数据结构与算法\高级数据结构.assets\线段树.png)

根节点保存下标0-5的所有元素的总和。左右两个字节点分别保存左右两半元素的和。最终叶子节点是每个元素的值。

**解法**：

1. 更新数组里某个元素的值

   从根节点出发，更新节点的数值，它保存的是数组元素的总和。修改的元素有可能会落在线段树的一些区间内，至少叶子结点是需要更新的，所以，要做的是从根节点往下，判断元素的下标是否在左边还是右边，然后更新分支里的结点大小。

2. 对数组某个区间段里的元素进行求和

   从根节点出发，判断所求的区间是否落在结点代表的区间中。如果所求的区间完全包含了结点所代表的的区间，那么就得加上该节点的数值。接下来，不断地往下寻找其他的子区间，最终得出所要求的总和。

**建议**：线段树实现书写起来很繁琐，需要不断练习。

**例题分析**：LeetCode 315题

## 1.5树状数组

**常用场景：**

1. 更新数组元素的数值
2. 求数组前K个元素的总和（或平均值）

**解法1**：线段树

+ 时间复杂度O(logn)

**解法2**：树状数组

+ 该问题只求前K个元素的总和，并不要求任意区间
+ 树状数组可以在O(logn）时间内完成上述操作
+ 相对于线段树，树状数组实现更简单

**特点：**

树状数组的数据结构有以下几个重要的基本特征

1. 利用数组来表示多叉树的结构，这一点与优先队列相似，优先队列用数组来表示完全二叉树，树状数组是==多叉树==
2. 树状数组的第一个节点是空节点
3. 如果节点tree[y]是节点tree[x]的父节点，那么需满足：y = x - ( x & ( -x ))

树状数组所解决的问题跟线段数类似。